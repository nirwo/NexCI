// --- Log Handling Functions ---\n\nlet latestBuildUrl = null; // Store URL for the latest build of the selected job\n\n// Fetch and display logs for the latest build URL\nasync function fetchAndDisplayLogs() {\n    const logDisplayArea = getElement(\'log-display-area\');\n    const logContentElement = getElement(\'log-content\');\n    const logErrorElement = getElement(\'log-error\');\n    const logLoadingIndicator = getElement(\'log-loading-indicator\');\n\n    if (!logDisplayArea || !logContentElement || !logErrorElement || !logLoadingIndicator) {\n        console.error(\"Log display UI elements not found.\");\n        return;\n    }\n\n    if (!latestBuildUrl) {\n        showError(\"No build selected or latest build URL is missing.\", \'log\');\n        logDisplayArea.style.display = \'block\'; // Show the area to display the error\n        return;\n    }\n\n    logLoadingIndicator.style.display = \'inline-block\';\n    logErrorElement.style.display = \'none\';\n    logContentElement.textContent = \'Loading logs...\';\n    logDisplayArea.style.display = \'block\';\n\n    // Hide other potentially visible sections\n    const timelineArea = getElement(\'timeline-area\');\n    if (timelineArea) timelineArea.style.display = \'none\';\n     const buildSummaryArea = getElement(\'build-summary-area\');\n    if (buildSummaryArea) buildSummaryArea.style.display = \'none\';\n\n    try {\n        console.log(`[DEBUG] Fetching log from: ${latestBuildUrl}consoleText`);\n        const response = await fetch(`${latestBuildUrl}consoleText`);\n        if (!response.ok) {\n            const errorText = await response.text(); // Try to get more error info\n            throw new Error(`HTTP Error: ${response.status} - ${response.statusText}. ${errorText}`);\n        }\n        const logText = await response.text();\n        logContentElement.textContent = logText;\n        console.log(\"[DEBUG] Log fetched successfully.\");\n\n    } catch (error) {\n        console.error(\"Error fetching logs:\", error);\n        showError(`Failed to load logs: ${error.message}`, \'log\');\n    } finally {\n        logLoadingIndicator.style.display = \'none\';\n    }\n}\n\n\n// Parse log text to extract structured timeline steps\n// Improved parsing logic\nfunction parseLogForTimeline(logText) {\n    if (!logText) return [];\n\n    const lines = logText.split(/\\r?\\n/);\n    const steps = [];\n    let currentStep = null;\n    let stageName = \'Declarative: Checkout SCM\'; // Default stage\n\n    // More robust regex\n    const stageRegex = /^\\s*\\[Pipeline\\] \\/{0,1}stage(?: \\(Declarative: (.*)\\))?$/; // Match stage start/end and capture name\n    const stepStartRegex = /^\\s*\\[Pipeline\\] ([a-zA-Z]+)$/; // Match general step start like [Pipeline] sh\n    const commandRegex = /^\\+\s+(.*)$/; // Match shell commands\n    const nodeRegex = /^Running on (.+) in (.+)$/; // Match node execution\n    const statusRegex = /^Finished: (SUCCESS|FAILURE|ABORTED|UNSTABLE)$/; // Match final build status\n    const errorMsgRegex = /^ERROR: (.*)$/i; // Match ERROR lines\n    const timeStampRegex = /^(\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\s+/; // Simple time HH:MM:SS.ms\n\n    // Simplified time parsing for duration - assumes logs have timestamps\n    let buildStartTime = null;\n    let lastTimestamp = null;\n\n    function parseTimestamp(line) {\n        const match = line.match(timeStampRegex);\n        if (match) {\n            // Create a Date object relative to today, assuming logs are recent\n            const timeParts = match[1].split(/[:.]/);\n            const now = new Date();\n            const date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), \n                                  parseInt(timeParts[0]), parseInt(timeParts[1]), parseInt(timeParts[2]), parseInt(timeParts[3]));\n            return date.getTime(); // milliseconds since epoch\n        }\n        return null;\n    }\n\n    lines.forEach(line => {\n        const timestamp = parseTimestamp(line);\n        if (timestamp) {\n            if (!buildStartTime) buildStartTime = timestamp;\n             lastTimestamp = timestamp;\n        }\n        line = line.replace(timeStampRegex, \'\').trim(); // Remove timestamp for cleaner regex matching\n\n        const stageMatch = line.match(stageRegex);\n        const stepStartMatch = line.match(stepStartRegex);\n        const commandMatch = line.match(commandRegex);\n        const nodeMatch = line.match(nodeRegex);\n        const statusMatch = line.match(statusRegex);\n        const errorMatch = line.match(errorMsgRegex);\n\n        if (stageMatch) {\n            // If it\'s a stage start line and captures a name, update stageName\n            if (line.includes(\'stage (Declarative:\') && stageMatch[1]) {\n                 stageName = stageMatch[1].trim();\n            }\n            // If it\'s a stage end line or a simple stage start, we might end the previous step\n             if (currentStep && !line.includes(\'Declarative:\')) { // Avoid ending step on the same line as stage name\n                 currentStep.status = \'SUCCESS\'; // Assume success if ending due to new stage/step\n                 if (currentStep.startTime && lastTimestamp) {\n                     currentStep.duration = lastTimestamp - currentStep.startTime;\n                 }\n                 steps.push(currentStep);\n                 currentStep = null;\n             }\n        } else if (stepStartMatch) {\n            // End previous step if exists\n             if (currentStep) {\n                currentStep.status = \'SUCCESS\'; // Assume success if ending due to new step\n                if (currentStep.startTime && lastTimestamp) {\n                    currentStep.duration = lastTimestamp - currentStep.startTime;\n                }\n                steps.push(currentStep);\n            }\n            // Start new step\n            currentStep = {\n                name: stepStartMatch[1],\n                status: \'RUNNING\',\n                stage: stageName,\n                startTime: lastTimestamp,\n                duration: null,\n                command: null,\n                node: null,\n                error: null\n            };\n        } else if (commandMatch && currentStep) {\n            currentStep.command = (currentStep.command ? currentStep.command + \'\\n\' : \'\') + commandMatch[1];\n        } else if (nodeMatch && currentStep) {\n            currentStep.node = nodeMatch[1];\n            // Optionally update stage if node line implies it\n             if (!currentStep.stage && nodeMatch[2]) {\n                 currentStep.stage = nodeMatch[2]; // Or some derivative\n             }\n        } else if (errorMatch && currentStep) {\n            currentStep.status = \'FAILURE\';\n            currentStep.error = (currentStep.error ? currentStep.error + \'\\n\' : \'\') + errorMatch[1];\n        } else if (statusMatch) {\n            // Final build status - could potentially mark the last step\n            if (currentStep) {\n                currentStep.status = statusMatch[1];\n                 if (currentStep.startTime && lastTimestamp) {\n                    currentStep.duration = lastTimestamp - currentStep.startTime;\n                }\n                steps.push(currentStep);\n                currentStep = null;\n            }\n             // Add a final step for the overall result if needed?\n             steps.push({ name: \'Build Result\', status: statusMatch[1], duration: null, stage: \'Summary\', startTime: lastTimestamp });\n        }\n    });\n\n    // Add the last running step if the log ended abruptly\n    if (currentStep) {\n         if (!currentStep.status || currentStep.status === \'RUNNING\') {\n             currentStep.status = \'UNKNOWN\'; // Or infer based on overall status if available\n         }\n          if (currentStep.startTime && lastTimestamp) {\n             currentStep.duration = lastTimestamp - currentStep.startTime;\n         }\n        steps.push(currentStep);\n    }\n\n    console.log(\"[DEBUG] Parsed Steps:\", steps);\n    return steps;\n}\n
